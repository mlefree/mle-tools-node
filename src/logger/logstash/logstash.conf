input {
  file {
    path => "/app/logs/*/*.log"
    start_position => "beginning"
    codec => "plain"
    ignore_older => 0
    discover_interval => 2
    stat_interval => 1
    close_older => 3600
    max_open_files => 4096
    file_sort_by => "last_modified"
    file_sort_direction => "desc"
    check_archive_validity => false
  }
}

filter {
  # Remove ANSI color codes (already correct)
 # mutate {
 #   gsub => ["message", "\x1B\[[0-9;]*[mK]", ""]
 # }

  grok {
    match => {
      "message" => "%{TIMESTAMP_ISO8601:timestamp}\|%{DATA:process_info}\|%{DATA:level}\s*:\s*(?:\[%{DATA:service}\]\s+)?%{GREEDYDATA:log_message}"
    }
    tag_on_failure => ["_grokparsefailure"]
  }


  # Extract tag from log_message if it exists
  if [log_message] {
    grok {
      match => {
        "log_message" => "^\(%{DATA:tag}\)\s*%{GREEDYDATA:clean_message}"
      }
      tag_on_failure => []
    }

    # If tag was extracted, update log_message to the clean version
    if [tag] {
      mutate {
        replace => { "log_message" => "%{clean_message}" }
        add_tag => [ "%{tag}" ]
        remove_field => ["clean_message"]
      }
    }
  }

  # FALLBACK: If ISO8601 fails, try the actual logger format
 # if "_grok_parse_failure_iso8601" in [tags] {
 #   mutate {
 #     remove_tag => ["_grok_parse_failure_iso8601"]
 #   }
 #   grok {
 #     match => {
 #       "message" => "%{YEAR:year}-%{MONTHNUM:month}-%{MONTHDAY:day} %{TIME:time}\|%{DATA:process_info}\|%{DATA:level}: (?:\[%{DATA:service}\] )?%{GREEDYDATA:log_message}"
 #     }
 #     tag_on_failure => ["grokparsefailure"]
 #   }
#
 #   # Reconstruct timestamp from parsed components
 #   if !("grokparsefailure" in [tags]) {
 #     mutate {
 #       add_field => { "timestamp" => "%{year}-%{month}-%{day} %{time}" }
 #     }
 #   }
 # }

  # Parse timestamp and extract date components (format matches logger output)
  date {
    match => [ "timestamp", "ISO8601", "yyyy-MM-dd HH:mm:ss.SSS" ]
    target => "@timestamp"
  }

  # Extract date components for index naming
  ruby {
    code => "
      begin
        time = event.get('@timestamp')
        if time
          event.set('year', time.year.to_s.rjust(4, '0'))
          event.set('month', time.month.to_s.rjust(2, '0'))
          event.set('day', time.day.to_s.rjust(2, '0'))
        else
          # Fallback to current date if timestamp parsing failed
          now = Time.now
          event.set('year', now.year.to_s.rjust(4, '0'))
          event.set('month', now.month.to_s.rjust(2, '0'))
          event.set('day', now.day.to_s.rjust(2, '0'))
        end
      rescue => e
        # Fallback on any error
        now = Time.now
        event.set('year', now.year.to_s.rjust(4, '0'))
        event.set('month', now.month.to_s.rjust(2, '0'))
        event.set('day', now.day.to_s.rjust(2, '0'))
      end
    "
  }

  # Set default service name if not extracted
  if ![service] {
    mutate {
      add_field => { "service" => "unknown" }
    }
  }

  # Extract service from file path as fallback
  if [service] == "unknown" {
    grok {
      match => { "path" => "/app/logs/%{WORD:service}/log-" }
    }
  }

  # Final fallback for service
   if [service] == "unknown" {
     mutate {
       replace => { "service" => "-" }
     }
   }

  # Clean up temporary fields
  mutate {
    remove_field => ["year_temp", "month_temp", "day_temp", "time"]
  }
}

output {
  stdout { codec => rubydebug }
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "app-logs"
    manage_template => false
    data_stream => false
  }
}
